# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Estimation of LD block regions
#' @description returns the estimation of LD block regions of given data.
#' @param geno A data frame or matrix of additive genotype data, each column is additive genotype of each SNP.
#' @param SNPinfo A data frame or matrix of SNPs information.  1st column is rsID and 2nd column is bp position.
#' @param CLQcut A numeric value of threshold for the correlation value |r|, between 0 to 1.
#' @param clstgap  An integer value to specifying the threshold of physical distance (bp) between two consecutive SNPs
#' which do not belong to the same clique, i.e., if a physical distance between two consecutive SNPs in a clique
#' greater than \code{clstgap}, then the algorithm split the cliques satisfying each
#' clique do not contain such consecutive SNPs
#' @param leng  An integer value to specify the number of SNPs in a preceding and a following region
#' of each sub-region boundary, every SNP in a preceding and every SNP in a following region need to be in weak LD.
#' @param MAFcut An numeric value to specifying the MAF threshold. 
#' @param subSegmSize  An integer value to specify the upper bound of the number of SNPs in a one-take sub-region.
#' @param appendRare If \code{appendRare = TRUE}, the algorithm append rare SNPs (MAF<MAFcut) to the constructed LD blocks or add a new LD blocks
#' @param checkLargest If \code{checkLargest = TRUE}, the algorithm use heuristic procedure to reduce runtime of CLQ-D execution
#' @param hrstType, string value with hrstType=c("near-nonhrst", "fast", "nonhrst")
#' 
#' <output>
#' @return  A data frame of block estimation result.
#' Each row of data frame shows the starting SNP and end SNP of each estimated LD block.
#' 
#' @export
BigLD <- function(corMat = NULL, CLQcut = 0.5, clstgap = 40000L, CLQmode = "maximal", hrstType = "fast", hrstParam = 200L, chrN = "chr1") {
    .Call('_recombClust_BigLD', PACKAGE = 'recombClust', corMat, CLQcut, clstgap, CLQmode, hrstType, hrstParam, chrN)
}

#' @title Estimation of LD block regions
#' @description \code{Big_LD} returns the estimation of LD block regions of given data.
#' @param OCM Correlation matrix
#' @param CLQcut A numeric value of threshold for the correlation value |r|, between 0 to 1.
#' @param clstgap  An integer value to specifying the threshold of physical distance (bp) between two consecutive SNPs
#' which do not belong to the same clique, i.e., if a physical distance between two consecutive SNPs in a clique
#' greater than \code{clstgap}, then the algorithm split the cliques satisfying each
#' clique do not contain such consecutive SNPs
#' @param hrstType, string value with hrstType=c("near-nonhrst", "fast", "nonhrst")
#' @param leng  An integer value to specify the number of SNPs in a preceding and a following region
#' of each sub-region boundary, every SNP in a preceding and every SNP in a following region need to be in weak LD.
#' @param MAFcut An numeric value to specifying the MAF threshold. 
#' @param subSegmSize  An integer value to specify the upper bound of the number of SNPs in a one-take sub-region.
#' @param appendRare If \code{appendRare = TRUE}, the algorithm append rare SNPs (MAF<MAFcut) to the constructed LD blocks or add a new LD blocks
#' @param checkLargest If \code{checkLargest = TRUE}, the algorithm use heuristic procedure to reduce runtime of CLQ-D execution
#' @param CLQmode A character string to specify the way to give priority among detected cliques, the algorithm gives priority to the largest clique
#' 
#' <output>
#' @return  A data frame of block estimation result.
#' Each row of data frame shows the starting SNP and end SNP of each estimated LD block.
#' 
#' @export
CLQD_mod <- function(CorMat, CLQcut = 0.2, clstgap = 40000L, hrstType = "fast", hrstParam = 200L, CLQmode = "maximal") {
    .Call('_recombClust_CLQD_mod', PACKAGE = 'recombClust', CorMat, CLQcut, clstgap, hrstType, hrstParam, CLQmode)
}

#' Write data to file
#'
#' @param columns string vector with column names
#' @param results Numerical vector with data
#' @param outputfile relative path to output data file
#' @return none
#' @export
CWriteResults <- function(columns, results, outputfile) {
    invisible(.Call('_recombClust_CWriteResults', PACKAGE = 'recombClust', columns, results, outputfile))
}

#' @title Get graphs data from addjacency matrix
#' @description \code{Big_LD} returns adjacency matrix graph data to test graph complexity
#' @param OCM Correlation matrix
#' @param hrstParam A numeric value of threshold for the correlation value |r|, between 0 to 1.
#' 
#' <output>
#' @return  A list with , cores, highcore and local_cores
#' \itemize{
#'  \item{"adjMatrix"}{adjacent matrix graph}
#'  \item{"cores"}{a maximal subgraph in which each vertex has at least degree k. }
#'  \item{"highcore"}{Number of cores with "cores">hrstParam}
#'  \item{"local_cores"}{local_cores}
#' }
#' 
#' @importFrom igraph graph_from_adjacency_matrix coreness
#' 
#' @export
get_graph_matrix_data <- function(OCM, hrstParam) {
    .Call('_recombClust_get_graph_matrix_data', PACKAGE = 'recombClust', OCM, hrstParam)
}

#' Get annotation data from hdf5
#'
#' Get model annotation data from hdf5 data file
#'
#' @param resfilename string, path and file name where models data is store.
#' @param resgroup Annotation obtained for the different models in LDMixture
#' @param datasets Range to look in
#' @return Annotation data from models
#' @export
getAnnotationDataHdf5 <- function(resfilename, resgroup, datasets) {
    .Call('_recombClust_getAnnotationDataHdf5', PACKAGE = 'recombClust', resfilename, resgroup, datasets)
}

#' Test if element exits
#' 
#' Test if group name or dataset name exists inside the hdf5 data file
#'
#' @param filename string, path and file name to search element.
#' @param element string, group or dataset name to search inside hdf5 data file.
#' @return A boolean indicating whether or not the element being searched exists
#' @export
existsHdf5Element <- function(filename, element) {
    .Call('_recombClust_existsHdf5Element', PACKAGE = 'recombClust', filename, element)
}

#' Create a group 
#' 
#' Create a group inside Hdf5 data file
#'
#' @param filename string, path and file name to search element.
#' @param element string, group name to be created inside the hdf5 data file.
#' @param overwrite boolean, if true this function overwrites existing group.
#' @return integer, if 0 the process was successful and group was created in 
#' the file
#' @export
setHdf5Group <- function(filename, element, overwrite) {
    .Call('_recombClust_setHdf5Group', PACKAGE = 'recombClust', filename, element, overwrite)
}

#' Create File
#' 
#' Create an empty Hdf5 data file
#'
#' @param filename string, path and file name to be created.
#' @param force boolean, if true this function overwrites existing group.
#' @return integer, if 0 the process was successful and group was created in 
#' the file
#' @export
createEmptyHdf5File <- function(filename, force = FALSE) {
    .Call('_recombClust_createEmptyHdf5File', PACKAGE = 'recombClust', filename, force)
}

#' Get dataset dimensions
#'
#' get dataset dimensions
#' 
#' @param filename, character array indicating the name of the file to create
#' @param element path to element, character array indicating the complete route to the element to query size (folder or dataset). 
#' @return dimension
#' @export
get_dimHdf5 <- function(filename, element) {
    .Call('_recombClust_get_dimHdf5', PACKAGE = 'recombClust', filename, element)
}

#' Get dataset dimensions
#'
#' get dataset dimensions
#' 
#' @param filename, character array indicating the name of the file to create
#' @param group, Character array, indicating the group where the data set is stored
#' @param datasets, Character array, indicating the datasets name column and/or row names belong
#' @param rownames character vector with row names. 
#' @param colnames character vector with column names. 
#' @return no data returned.
#' @export
write_dimNames <- function(filename, group, dataset, rownames, colnames, force = FALSE) {
    invisible(.Call('_recombClust_write_dimNames', PACKAGE = 'recombClust', filename, group, dataset, rownames, colnames, force))
}

#' @title LDmixture model to a pair of SNP-blocks
#' 
#' @description Runs LDmixture model to a pair of SNP-blocks
#' 
#' @param dat Matrix with the genotype data
#' @param resfilename string, path and file name to store results. By default
#' this runLDmixture stores data in recombClustResults.hdf5, if resfilename 
#' is empty then function works on memory. To work with big regions it is 
#' recommended to work with data on disk. Only use resfilename = "" when regions 
#' are small in order to prevent memory overflows and low performance.
#' @param resgroup string, folder inside a file where we want to store results. By default
#' runLDmixture stores data inside group "AllModels" in resfilename file.
#' @param overwrite boolean, (optional) either a logical value indicating whether
#' the output file can be overwritten or not, by default files are not overwritten.
#' @param grstart Numerical genomic region start
#' @param grend Numerical genomic region end
#' @param maxSteps Numerical with the maximum number of iterations run by the EM algorithm
#' @param prob0 Initial mixture probability.
#' @return A list with the LDmixture results 
#' \itemize{
#'  \item{"logMix"}{Log-likelihood of mixture model}
#'  \item{"logLD"}{Log-likelihood of linkage model}
#'  \item{"logNoLD"}{Log-likelihood of recomb model}
#'  \item{"BIC"}{BIC of the mixture vs the base model}
#'  \item{"prob"}{Proportion of chromosomes belonging to recomb model}
#'  \item{"steps"}{Number of iterations until converge of the EM algorithm}
#'  \item{"pval"}{P-value of the Chi-square test}
#'  \item{"r1"}{Responsibilities for recomb population of each chromosomes. It is
#'  only available for selected models (BIC > 10, pval > 0.05)}
#' }
#' @export
LDmixtureModel <- function(dat, resfilename, resgroup, grchr, grstart, grend, maxSteps = NULL, prob0 = NULL, blocksize = NULL) {
    .Call('_recombClust_LDmixtureModel', PACKAGE = 'recombClust', dat, resfilename, resgroup, grchr, grstart, grend, maxSteps, prob0, blocksize)
}

#' @title Remove columns and Rows from squared matrix
#' @description removeMatrixColsandRows removes the rows and columns indicated in vector indices vIndex from a matrix
#' @param Mat Matrix to remove index columns and rows
#' @param vIndex Rows and column numbers to be removed from a matrix
#' 
#' <output>
#' @return  The original matrix without rows and column index .
#' 
#' @export
removeMatrixColsandRows <- function(Mat, vIndex) {
    .Call('_recombClust_removeMatrixColsandRows', PACKAGE = 'recombClust', Mat, vIndex)
}

#' Covnert input data file, .vcf or .bed to gds 
#'
#' @param filename, string with route to file with .vcf, .bed or .gds data type
#' @return converted gds filename
#' @export
CGetDatafromFile <- function(file) {
    .Call('_recombClust_CGetDatafromFile', PACKAGE = 'recombClust', file)
}

#' Get's SNP-block pair
#'
#' @param filename, string with route to file with .vcf, .bed or .gds data type
#' @return converted gds filename
#' @export
CgdsSNPpairMatrix <- function(filteredsnp) {
    .Call('_recombClust_CgdsSNPpairMatrix', PACKAGE = 'recombClust', filteredsnp)
}

#' Get's SNP-block pair
#'
#' @param filename, string with route to file with .vcf, .bed or .gds data type
#' @return converted gds filename
#' @export
CvcfSNPpairMatrix <- function(filteredsnp) {
    .Call('_recombClust_CvcfSNPpairMatrix', PACKAGE = 'recombClust', filteredsnp)
}

#' Convert 3D-Matrix to 2D-Matrix
#'
#' @param 3D-matrix with allele, samples and SNPs information [allele,samples,SNPs]
#' @return 2D-matrix with one row with each sample-allel [sample-allele, SNP]
#' @export
CTransformtoSampleAlleles <- function(x, allele, sample, variable) {
    .Call('_recombClust_CTransformtoSampleAlleles', PACKAGE = 'recombClust', x, allele, sample, variable)
}

#' Compute correlation matrix
#' 
#' Compute correlation matrix from probabilitie matrix. 
#'
#' @param matrix, Numerical matrix with probabilites
#' @return matrix, Correlation matrix
#' @export
getCorrelationMatrix <- function(mat, absval = NULL) {
    .Call('_recombClust_getCorrelationMatrix', PACKAGE = 'recombClust', mat, absval)
}

#' Compute cluster Recomb freq by mean of voting
#'
#' @param mat with initial probabilities
#' @param sel overlap ranges
#' @return NumericVector with recombination probabilites
#' @export
getProbs <- function(mat, sel) {
    .Call('_recombClust_getProbs', PACKAGE = 'recombClust', mat, sel)
}

#' Compute cluster Recomb freq by mean of voting
#'
#' @param filename with initial probabilities
#' @param group String, inside we have one dataset for each chromosome
#' @param dataset String, chromosome dataset inside the group
#' @param selection overlap ranges
#' @param nCols Integer, number of columns in selection.
#' @param outgroup String output group
#' @param outdataset String output dataset
#' @return NumericVector with recombination probabilites
#' @export
getProbs_hdf5 <- function(filename, group, dataset, selection, nCols, outgroup = NULL, outdataset = NULL) {
    invisible(.Call('_recombClust_getProbs_hdf5', PACKAGE = 'recombClust', filename, group, dataset, selection, nCols, outgroup, outdataset))
}

