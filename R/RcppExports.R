# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Estimation of LD block regions
#' @description \code{Big_LD} returns the estimation of LD block regions of given data.
#' @param geno A data frame or matrix of additive genotype data, each column is additive genotype of each SNP.
#' @param SNPinfo A data frame or matrix of SNPs information.  1st column is rsID and 2nd column is bp position.
#' @param CLQcut A numeric value of threshold for the correlation value |r|, between 0 to 1.
#' @param clstgap  An integer value to specifying the threshold of physical distance (bp) between two consecutive SNPs
#' which do not belong to the same clique, i.e., if a physical distance between two consecutive SNPs in a clique
#' greater than \code{clstgap}, then the algorithm split the cliques satisfying each
#' clique do not contain such consecutive SNPs
#' @param leng  An integer value to specify the number of SNPs in a preceding and a following region
#' of each sub-region boundary, every SNP in a preceding and every SNP in a following region need to be in weak LD.
#' @param MAFcut An numeric value to specifying the MAF threshold. 
#' @param subSegmSize  An integer value to specify the upper bound of the number of SNPs in a one-take sub-region.
#' @param appendRare If \code{appendRare = TRUE}, the algorithm append rare SNPs (MAF<MAFcut) to the constructed LD blocks or add a new LD blocks
#' @param checkLargest If \code{checkLargest = TRUE}, the algorithm use heuristic procedure to reduce runtime of CLQ-D execution
#' @param hrstType, string value with hrstType=c("near-nonhrst", "fast", "nonhrst")
#' 
#' <output>
#' @return  A data frame of block estimation result.
#' Each row of data frame shows the starting SNP and end SNP of each estimated LD block.
#' 
#' @export
BigLD <- function(corMat = NULL, CLQcut = 0.5, clstgap = 40000L, CLQmode = "maximal", hrstType = "fast", hrstParam = 200L, chrN = "chr1") {
    .Call('_recombClust_BigLD', PACKAGE = 'recombClust', corMat, CLQcut, clstgap, CLQmode, hrstType, hrstParam, chrN)
}

#' @title Estimation of LD block regions
#' @description \code{Big_LD} returns the estimation of LD block regions of given data.
#' @param OCM Correlation matrix
#' @param CLQcut A numeric value of threshold for the correlation value |r|, between 0 to 1.
#' @param clstgap  An integer value to specifying the threshold of physical distance (bp) between two consecutive SNPs
#' which do not belong to the same clique, i.e., if a physical distance between two consecutive SNPs in a clique
#' greater than \code{clstgap}, then the algorithm split the cliques satisfying each
#' clique do not contain such consecutive SNPs
#' @param hrstType, string value with hrstType=c("near-nonhrst", "fast", "nonhrst")
#' @param leng  An integer value to specify the number of SNPs in a preceding and a following region
#' of each sub-region boundary, every SNP in a preceding and every SNP in a following region need to be in weak LD.
#' @param MAFcut An numeric value to specifying the MAF threshold. 
#' @param subSegmSize  An integer value to specify the upper bound of the number of SNPs in a one-take sub-region.
#' @param appendRare If \code{appendRare = TRUE}, the algorithm append rare SNPs (MAF<MAFcut) to the constructed LD blocks or add a new LD blocks
#' @param checkLargest If \code{checkLargest = TRUE}, the algorithm use heuristic procedure to reduce runtime of CLQ-D execution
#' @param CLQmode A character string to specify the way to give priority among detected cliques, the algorithm gives priority to the largest clique
#' 
#' <output>
#' @return  A data frame of block estimation result.
#' Each row of data frame shows the starting SNP and end SNP of each estimated LD block.
#' 
#' @export
CLQD_mod <- function(CorMat, CLQcut = 0.2, clstgap = 40000L, hrstType = "fast", hrstParam = 200L, CLQmode = "maximal") {
    .Call('_recombClust_CLQD_mod', PACKAGE = 'recombClust', CorMat, CLQcut, clstgap, hrstType, hrstParam, CLQmode)
}

#' Write data to file
#'
#' @param columns string vector with column names
#' @param results Numerical vector with data
#' @param outputfile relative path to output data file
#' @return none
#' @export
CWriteResults <- function(columns, results, outputfile) {
    invisible(.Call('_recombClust_CWriteResults', PACKAGE = 'recombClust', columns, results, outputfile))
}

#' @title Get graphs data from addjacency matrix
#' @description \code{Big_LD} returns adjacency matrix graph data to test graph complexity
#' @param OCM Correlation matrix
#' @param hrstParam A numeric value of threshold for the correlation value |r|, between 0 to 1.
#' 
#' <output>
#' @return  A list with , cores, highcore and local_cores
#' \itemize{
#'  \item{"adjMatrix"}{adjacent matrix graph}
#'  \item{"cores"}{a maximal subgraph in which each vertex has at least degree k. }
#'  \item{"highcore"}{Number of cores with "cores">hrstParam}
#'  \item{"local_cores"}{local_cores}
#' }
#' 
#' @importFrom igraph graph_from_adjacency_matrix coreness
#' 
#' @export
get_graph_matrix_data <- function(OCM, hrstParam) {
    .Call('_recombClust_get_graph_matrix_data', PACKAGE = 'recombClust', OCM, hrstParam)
}

#' Run LDmixture model to a pair of SNP-blocks
#'
#' @param dat Matrix with the genotype data
#' @param maxSteps Numerical with the maximum number of iterations run by the EM algorithm
#' @param prob0 Initial mixture probability.
#' @return A list with the LDmixture results
#' \itemize{
#'  \item{"logMix"}{Log-likelihood of mixture model}
#'  \item{"logLD"}{Log-likelihood of linkage model}
#'  \item{"logNoLD"}{Log-likelihood of recomb model}
#'  \item{"BIC"}{BIC of the mixture vs the base model}
#'  \item{"prob"}{Proportion of chromosomes belonging to recomb model}
#'  \item{"steps"}{Number of iterations until converge of the EM algorithm}
#'  \item{"pval"}{P-value of the Chi-square test}
#'  \item{"r1"}{Responsibilities for recomb population of each chromosomes. It is
#'  only available for selected models (BIC > 10, pval > 0.05)}
#' }
#' @export
LDmixtureModel <- function(dat, maxSteps = NULL, prob0 = NULL, blocksize = NULL) {
    .Call('_recombClust_LDmixtureModel', PACKAGE = 'recombClust', dat, maxSteps, prob0, blocksize)
}

#' @title Remove columns and Rows from squared matrix
#' @description \code{removeMatrixColsandRows} removes the rows and columns indicated in vector indices vIndex from a matrix
#' @param Mat Matrix to remove index columns and rows
#' @param vIndex Rows and column numbers to be removed from a matrix
#' 
#' <output>
#' @return  The original matrix without rows and column index .
#' 
#' @export
removeMatrixColsandRows <- function(Mat, vIndex) {
    .Call('_recombClust_removeMatrixColsandRows', PACKAGE = 'recombClust', Mat, vIndex)
}

#' Covnert input data file, .vcf or .bed to gds 
#'
#' @param filename, string with route to file with .vcf, .bed or .gds data type
#' @return converted gds filename
#' @export
CGetDatafromFile <- function(file) {
    .Call('_recombClust_CGetDatafromFile', PACKAGE = 'recombClust', file)
}

#' Get's SNP-block pair
#'
#' @param filename, string with route to file with .vcf, .bed or .gds data type
#' @return converted gds filename
#' @export
CgdsSNPpairMatrix <- function(filteredsnp) {
    .Call('_recombClust_CgdsSNPpairMatrix', PACKAGE = 'recombClust', filteredsnp)
}

#' Get's SNP-block pair
#'
#' @param filename, string with route to file with .vcf, .bed or .gds data type
#' @return converted gds filename
#' @export
CvcfSNPpairMatrix <- function(filteredsnp) {
    .Call('_recombClust_CvcfSNPpairMatrix', PACKAGE = 'recombClust', filteredsnp)
}

#' Convert 3D-Matrix to 2D-Matrix
#'
#' @param 3D-matrix with allele, samples and SNPs information [allele,samples,SNPs]
#' @return 2D-matrix with one row with each sample-allel [sample-allele, SNP]
#' @export
CTransformtoSampleAlleles <- function(x, allele, sample, variable) {
    .Call('_recombClust_CTransformtoSampleAlleles', PACKAGE = 'recombClust', x, allele, sample, variable)
}

#' Compute correlation matrix
#' 
#' Compute correlation matrix from probabilitie matrix. 
#'
#' @param matrix, Numerical matrix with probabilites
#' @return matrix, Correlation matrix
#' @export
getCorrelationMatrix <- function(mat, absval = NULL) {
    .Call('_recombClust_getCorrelationMatrix', PACKAGE = 'recombClust', mat, absval)
}

#' Compute cluster Recomb freq by mean of voting
#'
#' @param mat with initial probabilities
#' @param sel overlap ranges
#' @return NumericVector with recombination probabilites
#' @export
getProbs <- function(mat, sel) {
    .Call('_recombClust_getProbs', PACKAGE = 'recombClust', mat, sel)
}

